#
#       _ _______          _ ____
#      | |__   __|        | |  _ \
#   ___| | _| | ___   ___ | | |_) | _____  __TM
#  / __| |/ / |/ _ \ / _ \| |  _ < / _ \ \/ /
#  \__ \   <| | (_) | (_) | | |_) | (_) >  <
#  |___/_|\_\_|\___/ \___/|_|____/ \___/_/\_\
#

# Requirements:
#   Skript (Tested with 2.6-alpha1)
#   skript-reflect (Tested with the latest build from GitHub - https://github.com/TPGamesNL/skript-reflect/actions)
#   ThatPacketAddon (Tested with 1.0-BETA.3)

# Tested on Airplane, 1.16.5

# If you encounter any issue, feel free to report it on GitHub:
# 	https://github.com/Mr-Darth/skToolBox/issues

# Please do not edit anything below unless you know what you are doing!

# Imports :D!
import:
	java.text.DecimalFormat

	ch.njol.skript.Skript
	ch.njol.skript.log.SkriptLogger
	ch.njol.skript.log.BlockingLogHandler
	ch.njol.skript.lang.VariableString

	org.bukkit.inventory.ItemFlag

#
#                                    (_)
#    _____  ___ __  _ __ ___  ___ ___ _  ___  _ __  ___ TM
#   / _ \ \/ / '_ \| '__/ _ \/ __/ __| |/ _ \| '_ \/ __|
#  |  __/>  <| |_) | | |  __/\__ \__ \ | (_) | | | \__ \
#   \___/_/\_\ .__/|_|  \___||___/___/_|\___/|_| |_|___/
#            | |
#            |_|
#

# Name: Not boolean
# Description: Returns the logically opposite value of the given booleans.
# Usage: set {afk::%player%} to !{afk::%player%}
expression:
	patterns:
		([the] (opposite|toggled|flipped) [boolean[s]]|not) %$booleans%
		!%boolean%
	return type: boolean
	get:
		loop exprs-1:
			add 1 to {_index}
			set {_output::%{_index}%} to false if loop-value is true, else true
		return {_output::*}

# Name: Degrees and radians conversions
# Description: Converts degrees to radians and vice versa.
# Usage: set {_rad} to 180 degrees as radians
expression:
	patterns:
		%$numbers% [degree[s]] (in|to|as) rad[ian][s]
		%$numbers% [rad[ian][s]] (in|to|as) degree[s]
	return type: number
	parse:
		set {_conversions::*} to 0.017453292519943295 and 57.29577951308232
		continue
	get:
		loop exprs-1:
			add 1 to {_index}
			set {_value} to loop-value
			set {_output::%{_index}%} to {_value} * {_conversions::%pattern%} 
		return {_output::*}

# Name: Mathematical constants
# Description: Returns the value of pi or Euler's number.
# Usage: set {_points} to {_radius} * 2 * pi
expression [the] [value of] (pi|1¦e[uler['s]] [num[ber]]):
	return type: number
	get:
		return 3.141592653589793 if parser mark is 0, else 2.718281828459045

# Name: Mean
# Description: Returns the average or geometric mean of a list of numbers.
# Usage: set {_rating} to average value of {ratings::*}
expression (average|(arithmetic|1¦geometric) mean) of %numbers%:
	return type: number
	get:
		return (sum(exprs-1) / size of exprs-1) if parser mark is 0, else (product(exprs-1) ^ (1 / (size of exprs-1)))

# Name: Reversed strings
# Description: Reverses the given strings.
# Usage: broadcast backwards "abcdef"
expression (reverse[d]|backwards) [(string|text)[s]] %$strings%:
	return type: string
	get:
		loop exprs-1:
			add 1 to {_index}
			set {_value} to loop-value
			set {_output::%{_index}%} to join (characters at (integers from (length of {_value}) to 1) of {_value})
		return {_output::*}

# Name: String split every N characters
# Description: Splits a string by every N characters.
# Usage: send split arg-1 every 20 characters
plural expression:
	patterns:
		%string% split [(by|at)] every %number% char[acter][s]
		split %string% [(by|at)] every %number% char[acter][s]
	return type: strings
	get:
		return expr-1 if expr-2 < 0, else (regex split expr-1 by "(?<=\G.{%expr-2%})(?!$)")

# Name: Soundex value
# Description: Returns the soundex value of a string. (See: https://en.wikipedia.org/wiki/Soundex)
# Usage: send "Use `command` not `%arg-1%`" if soundex value of "command" is soundex value of arg-1
string property soundex [value]:
	return type: string
	get:
		return "" if expr-1 ? "" is empty
		set {_input} to capitalized expr-1
		set {_output} to first character of {_input}
		loop characters at (integers from 2 to (length of {_input} + 1)) in {_input}:
			return {_output} if length of {_output} >= 4  
			set {_digit} to character at (index of loop-value in "ABCDEFGHIJKLMNOPQRSTUVWXYZ") in "01230120022455012623010202"
			{_digit} is not "0" or last character of {_output}
			set {_output} to join {_output} and {_digit}
		loop 4 - length of {_output} times:
			set {_output} to join {_output} and "0"
		return {_output}

# Name: Number of occurrences
# Description: Returns the number of occurrences of a certain sequence in a string.
# Usage: set {_i} to number of occurrences of "E" in player's message
expression [the] [(number|amount) of] (occurrences|repetitions) of %string% in %$strings%:
	return type: number
	get:
		loop exprs-2:
			add size of (split "%loop-value%" by "%expr-1%") - 1 to {_output}
		return {_output}

# Name: Parsed expressions
# Description: Returns the given strings with expressions parsed.
#              For instance, inputting "hello %%{var}%%" will replace "%%{var}%%" with the actual value.
# Usage: set {_message} to parse expressions in message
expression:
	patterns:
		parsed (expressions|var[iable]s) in %$strings%
		%$strings% with (expressions|var[iable]s) parsed
	return type: string
	parse:
		set {_blockingLogHandler} to new BlockingLogHandler()
		continue
	get:
		# Start a blocking log handler to block errors from invalid expressions
		set {_logHandler} to SkriptLogger.startLogHandler({_blockingLogHandler})
		loop exprs-1:
			add 1 to {_index}
			set {_output::%{_index}%} to VariableString.newInstance(loop-value).toString(event)
		set {_} to {_logHandler}.stop()
		return {_output::*}

# Name: Formatted numbers
# Description: Formats the given numbers using a given decimal format.
#              The format is constructed at parse time, therefore it must be a string literal.
# Usage: send "Money: %formatted player's balance%"
expression:
	patterns:
		formatted %$numbers% (from|with|using|as) [[decimal] format] %string%
		%$numbers% formatted (from|with|using|as) [[decimal] format] %string%
	return type: strings
	parse:
		if expr-2 is not instance of VariableString:
			Skript.error("The decimal format must be a string literal.")
			stop
		else if expr-2.isSimple() is false:
			Skript.error("The decimal format must be a string literal.")
			stop
		set {_decimalFormat} to try new DecimalFormat(expr-2.getSingle(null))
		continue if {_decimalFormat} is set
		Skript.error("Invalid decimal format: %expr-2%")
	get:
		loop exprs-1:
			add 1 to {_index}
			set {_output::%{_index}%} to {_decimalFormat}.format(loop-value)
		return {_output::*}

# Name: Ordinal number
# Description: Ordinal numerals represent the position in a sequential order (e.g. 1st, 2nd, 3rd, etc.)
# Usage: send "You are the %ordinal of {pos::%player%}% person in the queue."
number property ordinal [(numeral|number|value)]:
	return type: string
	parse:
		set {_suffixes::*} to "st", "nd", "rd", "th", "th", "th", "th", "th", "th" 
		continue
	get:
		return "%expr-1%%{_suffixes::%mod(expr-1, 10) if expr-1 is not 11, 12 or 13, else 0%} ? "th"%"

# Name: Roman numeral
# Description: Returns the roman numeral of a number
# Usage: send "Sharpness level: %roman numeral of (level of sharpness of player's tool)%"
number property roman numeral:
	return type: string
	parse:
		set {_roman::*} to "M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV" and "I"
		set {_arab::*} to 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4 and 1
		continue
	get:
		set {_number} to expr-1
		loop {_arab::*}:
			loop {_number} / loop-value times:
				set {_output} to join {_output} and {_roman::%loop-index-1%}
				subtract loop-value-1 from {_number}
		return {_output}

# Name: Arabic numeral
# Description: Converts a roman numeral back to an integer.
# Usage: set {_level} to arabic numeral of message
string property arab[ic] numeral:
	return type: number
	parse:
		set {_roman::*} to "M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV" and "I"
		set {_arab::*} to 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4 and 1
		continue
	get:
		set {_numeral} to expr-1
		loop {_roman::*}:
			while {_numeral} starts with loop-value:
				add {_arab::%loop-index%} to {_output}
				set {_remainingCharacters} to (length of {_numeral}) - (length of loop-value)
				if {_remainingCharacters} is not 0:
					set {_numeral} to last {_remainingCharacters} characters of {_numeral}
				else:
					delete {_numeral}
		return {_output}

# Name: Rounded numbers
# Description: Rounds the given numbers to a certain amount of decimal places (smaller
#              than or equal to the number accuracy option in config), or to the nearest multiple of a number.
# Usage: set {_rnd} to rounded {_xp} to 1 decimal place
expression:
	patterns:
		[the] rounded %$numbers% (at|with|by|to) %number% decimal[s] [place[s]]
		[the] rounded %$numbers% to [the] nearest [multiple] of %number%
	return type: numbers
	get:
		set {_precision} to (10 ^ (rounded down -1 * expr-2)) if pattern is 1, else expr-2
		loop exprs-1:
			add 1 to {_index}
			set {_number} to loop-value
			set {_output::%{_index}%} to (rounded ({_number} / {_precision})) * {_precision}
		return {_output::*}

# Name: Factorial
# Description: Returns the factorial value of an integer.
# Usage: set {_combinations} to factorial {elements}
expression:
	return type: number
	patterns:
		factorial [value] [of] %$numbers%
		%$numbers%['[s]] factorial [value]
		%number%!
	get:
		return product(all integers from 1 to expr-1) if expr-1 is not 0, else 1

# Name: Protocol version
# Description: Gets the protocol version of a client. (See: https://wiki.vg/Protocol_version_numbers)
# Usage: kick player due to "Nope..." if protocol version of player <= 578
# Note: Requires Paper
player property protocol version:
	return type: number
	get:
		return expr-1.getProtocolVersion()

# Name: Client brand name
# Description: Returns a player's client brand name. If the client didn't send this information, the brand name will not be set.
#              For the Notchian client this name defaults to 'vanilla'. Some modified clients report other names such as forge.
#              Do note that not all modified clients have a custom brand name.
# Usage: kick player due to "Nope..." if player's client brand name is not "vanilla"
# Note: Requires Paper
player property [client] brand [name]:
	return type: string
	get:
		return expr-1.getClientBrandName()

# Name: Glowing item
# Description: Returns a glowing version of an item.
# Usage: give player shiny wooden axe
expression [a] (glowing|shiny) %$itemtypes%:
	return type: itemtypes
	get:
		loop exprs-1:
			add 1 to {_index}
			set {_output::%{_index}%} to loop-value
			continue if enchantments of {_output::%{_index}%} exist	
			enchant {_output::%{_index}%} with (lure if loop-value is not a fishing rod, else infinity)
			set {_meta} to {_output::%{_index}%}.getItemMeta()
			set {_} to {_meta}.addItemFlags([ItemFlag.HIDE_ENCHANTS])
			set {_} to {_output::%{_index}%}.setItemMeta({_meta})
		return {_output::*}

# Name: Dyed item
# Description: Returns a dyed version of an item.
# Usage: give player leather helmet colored rgb(20, 20, 90)
expression %$itemtypes% (colo[u]red|dyed|painted) %color%:
	return type: itemtypes
	get:
		loop exprs-1:
			add 1 to {_index}
			set {_output::%{_index}%} to loop-value
			dye {_output::%{_index}%} expr-2
		return {_output::*}

# Name: Time until
# Description: Returns the time until a given date.
# Usage: set {remainingTime} to time until {restart}
expression time until %date%:
	return type: timespan
	get:
		return difference between now and expr-1 if expr-1 >= now
		return
